const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const db = require('../config/db');
const emailService = require('../services/emailService');
const { generateReferralCode } = require('../utils/codeGenerator');

// @desc    Register a new user
// @route   POST /api/auth/register
// @access  Public
const register = async (req, res, next) => {
  const { name, email, password } = req.body;
  const [firstName, ...lastNameParts] = name ? name.split(' ') : ['', ''];
  const lastName = lastNameParts.join(' ') || '';

  try {
    // Check if user exists
    const [existingUsers] = await db.query('SELECT * FROM users WHERE email = ?', [email]);
    if (existingUsers.length > 0) {
      return res.status(400).json({ message: 'User already exists' });
    }

    // Hash password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    // Create user
    // Assuming role defaults to 'customer' in DB or we should specify it if column exists.
    // The previous code didn't specify role, so DB default likely 'customer'.
    // Step 769 showed 'role' column. If it has default 'customer', fine.
    // If not, I should add it. I'll rely on DB default for now as per previous code.
      // Generate referral code
      const referralCode = generateReferralCode(firstName);

      const [result] = await db.query('INSERT INTO users (id, first_name, last_name, email, password_hash, personal_referral_code) VALUES (UUID(), ?, ?, ?, ?, ?)',
          [firstName, lastName, email, hashedPassword, referralCode]
    );
        
    const id = result.insertId; // Note: UUID logic might behave differently regarding insertId? 
    // wait, if "id" column is UUID(), insertId might be 0.
    // But previous code used `result.insertId`. Let's stick to it, but also select by email to get UUID if needed?
    // Actually, `INSERT INTO ... VALUES (UUID(), ...)`
    // MySQL LAST_INSERT_ID() doesn't work for UUID generated by UUID().
    // However, the JWT needs the ID.
    // If previous logic worked, maybe it wasn't using UUID or I missed something.
    // Step 787 Line 30: `VALUES (UUID(), ...)`
    // Line 34: `const id = result.insertId;`
    // Line 35: `jwt.sign({ id }, ...)`
    // If `id` is 0, then all users have ID 0 in token? That's bad.
    // I should probably query the user back by email to get the ID.
    
    // Improvement: Fetch the user to get the true ID.
      const [newUser] = await db.query('SELECT id, role, created_at, personal_referral_code FROM users WHERE email = ?', [email]);
    const user = newUser[0];
    
    const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: '30d' });

    // Set HttpOnly Cookie
    res.cookie('token', token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 24 * 60 * 60 * 1000 // 1 day
    });

    res.status(201).json({
      id: user.id,
      name,
      email,
        email,
      role: user.role,
        personal_referral_code: user.personal_referral_code
    });

      // Send Welcome Email (Non-blocking)
      (async () => {
          try {
              await emailService.sendWelcome(email, firstName);
              console.log(`✅ Welcome Email sent to ${email}`);
          } catch (err) {
              console.error("❌ Welcome Email Failed:", err.message);
          }
      })();
  } catch (err) {
    next(err);
  }
};

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
const login = async (req, res, next) => {
  const { email, password } = req.body;

  try {
    const [users] = await db.query('SELECT * FROM users WHERE email = ? AND is_deleted = 0', [email]);
    
    if (users.length === 0) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    const user = users[0];
    const isMatch = await bcrypt.compare(password, user.password_hash);

    if (isMatch) {
      const token = jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: '30d' });

      // Set HttpOnly Cookie
      res.cookie('token', token, {
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
          maxAge: 24 * 60 * 60 * 1000 // 1 day
      });

      res.json({
        id: user.id,
        name: `${user.first_name} ${user.last_name}`,
        email: user.email,
        role: user.role,
        has_password: true,
          personal_referral_code: user.personal_referral_code
      });

        // Send Login Alert (Non-blocking)
        (async () => {
            try {
                await emailService.sendLoginAlert(user.email);
                console.log(`✅ Login Alert Email sent to ${user.email}`);
            } catch (err) {
                console.error("❌ Login Alert Email Failed:", err.message);
            }
        })();
    } else {
      res.status(400).json({ message: 'Invalid credentials' });
    }
  } catch (err) {
    next(err);
  }
};

// @desc    Get current logged in user
// @route   GET /api/auth/me
// @access  Private
const getMe = async (req, res) => {
    // req.user is set by authMiddleware
    // Ensure we don't leak password_hash, but send has_password flag
    const user = { ...req.user };
    const hasPassword = !!user.password_hash;
    
    delete user.password_hash; 
    
    res.json({
        ...user,
        has_password: hasPassword
    });
};

// @desc    Logout user / clear cookie
// @route   POST /api/auth/logout
// @access  Public
const logout = (req, res) => {
    res.clearCookie('token', {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict'
    });
    res.json({ message: 'Logged out successfully' });
};

// ============= OAUTH SECTION =============
const { OAuth2Client } = require('google-auth-library');
const googleClient = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

// Helper to generate App's JWT Token
const generateToken = (id, role) => {
    return jwt.sign({ id, role }, process.env.JWT_SECRET, { expiresIn: '30d' });
};

// @desc    Login with Google
// @route   POST /api/auth/google
// @access  Public
const axios = require('axios');

// @desc    Login with Google
// @route   POST /api/auth/google
// @access  Public
const googleLogin = async (req, res) => {
    const { token } = req.body; // Can be ID Token or Access Token

    if (!token) {
        return res.status(400).json({ message: 'Token is required' });
    }

    try {
        let name, email, picture, googleId;

        // Try verifying as ID Token first
        try {
            const ticket = await googleClient.verifyIdToken({
                idToken: token,
                audience: process.env.GOOGLE_CLIENT_ID,
            });
            const payload = ticket.getPayload();
            name = payload.name;
            email = payload.email;
            picture = payload.picture;
            googleId = payload.sub;
        } catch (idTokenError) {
            // If ID Token verification fails, try as Access Token
            console.log('ID Token verification failed, trying Access Token...', idTokenError.message);
            
            const userInfoResponse = await axios.get('https://www.googleapis.com/oauth2/v3/userinfo', {
                headers: { Authorization: `Bearer ${token}` }
            });
            
            const payload = userInfoResponse.data;
            name = payload.name;
            email = payload.email;
            picture = payload.picture;
            googleId = payload.sub;
        }

        // 2. Check Database for Existing User
        const [users] = await db.execute('SELECT * FROM users WHERE email = ?', [email]);
        let user = users[0];

        if (user) {
            // Existing User: Link Google ID if missing
            if (!user.google_id) {
                await db.execute(
                    'UPDATE users SET google_id = ?, profile_pic = ? WHERE id = ?',
                    [googleId, picture, user.id]
                );
            }
        } else {
            // New User: Create Account
            const nameParts = (name || 'Google User').split(' ');
            const firstName = nameParts[0];
            const lastName = nameParts.slice(1).join(' ') || '';

            const referralCode = generateReferralCode(firstName);

            const [result] = await db.execute(
                'INSERT INTO users (id, first_name, last_name, email, google_id, role, profile_pic, personal_referral_code) VALUES (UUID(), ?, ?, ?, ?, ?, ?, ?)',
                [firstName, lastName, email, googleId, 'customer', picture, referralCode]
            );
            
            // Fetch the created user
            const [newUsers] = await db.execute('SELECT * FROM users WHERE google_id = ?', [googleId]);
            user = newUsers[0];
        }

        // 3. Issue JWT
        const appToken = generateToken(user.id, user.role || 'customer');

        // Set HttpOnly Cookie
        res.cookie('token', appToken, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'strict',
            maxAge: 30 * 24 * 60 * 60 * 1000
        });

        res.json({
            user: {
                id: user.id,
                name: `${user.first_name} ${user.last_name}`.trim(),
                email: user.email,
                role: user.role,
                pic: user.profile_pic,
                has_password: !!user.password_hash,
                personal_referral_code: user.personal_referral_code
            }
        });

    } catch (error) {
        console.error("Google Auth Error:", error.message);
        
        // Detailed file logging
        const fs = require('fs');
        const path = require('path');
        const logPath = path.join(__dirname, '../logs/google_auth_error.log');
        const logEntry = `[${new Date().toISOString()}] Error: ${error.message}\nStack: ${error.stack}\nToken: ${token}\n\n`;
        try {
            if (!fs.existsSync(path.dirname(logPath))) fs.mkdirSync(path.dirname(logPath));
            fs.appendFileSync(logPath, logEntry);
        } catch (fsError) {
            console.error("Failed to write log:", fsError.message);
        }

        res.status(401).json({ message: "Invalid Google Token" });
    }
};

// @desc    Login with Apple
// @route   POST /api/auth/apple
// @access  Public
const appleLogin = async (req, res) => {
    // Apple Sign-In requires:
    // 1. Paid Apple Developer Account ($99/year)
    // 2. Service ID configuration in Apple Developer Console
    // 3. Private key file for token verification
    // 
    // Once configured, use 'apple-signin-auth' library:
    // const appleSignin = require('apple-signin-auth');
    // const payload = await appleSignin.verifyIdToken(token, { audience: APPLE_CLIENT_ID });
    
    res.status(501).json({ 
        message: "Apple Login requires paid developer account configuration.",
        setup_url: "https://developer.apple.com/sign-in-with-apple/"
    });
};

module.exports = {
    register,
    login,
    getMe,
    logout,
    googleLogin,
    appleLogin
};
